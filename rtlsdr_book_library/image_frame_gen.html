
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Image Framing Script - Used by the Transmitter for Frame Generation</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-08-27"><meta name="DC.source" content="image_frame_gen.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Image Framing Script - Used by the Transmitter for Frame Generation</h1><!--introduction--><p>The code loads the image to be transmitted and implements a segmentation process to store columns of the image in individual frames. These frames are constructed from a header which contains the preamble sequence and information fields, and the payload with appended padding. The padding ensures that all frames are of equal length.</p><p>The frame structure used is shown here:</p><p>General Frame Structure: [___Header___|_____________Payload_____________]</p><p>Normal Frame - with pad: [___Header___|__________Data_________|_Padding_]</p><p>When the data in a frame is less than the data field length:</p><p>Padding increases:       [___Header___|______Data_____|_____Padding_____]</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Obtain Parameters Set in the Simulink Block Mask</a></li><li><a href="#2">Declare Protocol Parameters</a></li><li><a href="#3">Frame Header Structure</a></li><li><a href="#4">Message Acquisition &amp; Frame/ Padding Calculation</a></li><li><a href="#5">Data Segmentation, Payload Creation &amp; Frame Construction</a></li><li><a href="#6">Software, Simulation Examples and Design Exercises Licence Agreement  %%</a></li><li><a href="#7">Audio Tracks used in Simulations Examples and Design Exercises</a></li></ul></div><h2>Obtain Parameters Set in the Simulink Block Mask<a name="1"></a></h2><pre class="codeinput">frm.filename = get_param(gcbh,<span class="string">'filename'</span>);                                                  <span class="comment">% obtain the filename of the image to be sent</span>
frm.binary_len = str2num( get_param(gcbh,<span class="string">'binary_len'</span>) );                                   <span class="comment">% obtain the ASCII length and convert char type to num</span>
frm.fs = str2num( get_param(gcbh,<span class="string">'fs'</span>) );                                                   <span class="comment">% obtain the sampling rate and convert char type to num</span>
</pre><h2>Declare Protocol Parameters<a name="2"></a></h2><pre class="codeinput"><span class="comment">% frame length declaration</span>
frm.frame_len = 1000;                                                                       <span class="comment">% total length of a frame</span>

<span class="comment">% bit length declarations</span>
frm.seq_num_bit_len = 8;                                                                    <span class="comment">% # of bits in header - frame sequence number length</span>
frm.end_flag_bit_len = 1;                                                                   <span class="comment">% # of bits in header - end frame flag length</span>
frm.header_bit_len = 8;                                                                     <span class="comment">% # of bits in header - header length</span>
frm.payload_bit_len = 10;                                                                   <span class="comment">% # of bits in header - payload length</span>
frm.pad_bit_len = 9;                                                                        <span class="comment">% # of bits in header - padding length</span>
</pre><h2>Frame Header Structure<a name="3"></a></h2><pre class="codeinput"><span class="comment">%-------------------------------------------------------------------------%</span>
<span class="comment">% Frame Header- [preamble, sequence number, end flag, header length,</span>
<span class="comment">%                payload length, padding length]</span>
<span class="comment">%-------------------------------------------------------------------------%</span>

<span class="comment">% set the preamble in unipolar form - used at the beginning of each frame</span>
frm.preamble = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1];
frm.preamble_len = length(frm.preamble);                                                    <span class="comment">% calculate decimal length of the preamble sequence</span>
frm.preamble_pad_len = rem(frm.preamble_len,2);                                             <span class="comment">% determine if preamble requires padding</span>
frm.preamble_pad = zeros(1,frm.preamble_pad_len);                                           <span class="comment">% create padding to make preamble an even length (if required)</span>

<span class="comment">% determine the length of the header from the individual field lengths</span>
frm.header_len = frm.preamble_len<span class="keyword">...</span><span class="comment">                                                        % calculate the full length of the header (bits)</span>
    + frm.preamble_pad_len<span class="keyword">...</span>
    + frm.seq_num_bit_len<span class="keyword">...</span>
    + frm.end_flag_bit_len<span class="keyword">...</span>
    + frm.header_bit_len<span class="keyword">...</span>
    + frm.payload_bit_len<span class="keyword">...</span>
    + frm.pad_bit_len;

frm.payload_len = frm.frame_len - frm.header_len;                                           <span class="comment">% calculate the # of available payload storage bits in a frame</span>
frm.data_len = 800;                                                                         <span class="comment">% set at this value to transmit one pixel column per frame</span>

<span class="comment">%-------------------------------------------------------------------------%</span>
<span class="comment">% convert decimal lengths of fields to binary and construct header</span>
frm.end_flag_low = 0;                                                                       <span class="comment">% declare data end flag low for all frames but last</span>
frm.end_flag_high = 1;                                                                      <span class="comment">% declare data end flag high for last frame</span>
frm.header_len_bits = de2bi(frm.header_len,frm.header_bit_len,<span class="string">'left-msb'</span>);                  <span class="comment">% convert decimal header length to binary representation</span>
frm.payload_len_bits = de2bi(frm.payload_len,frm.payload_bit_len,<span class="string">'left-msb'</span>);               <span class="comment">% convert decimal payload length to binary representation</span>

frm.header_norm = [frm.preamble,<span class="keyword">...</span><span class="comment">                                                         % construct normal frame header with end flag low</span>
    frm.preamble_pad,<span class="keyword">...</span>
    frm.end_flag_low,<span class="keyword">...</span>
    frm.header_len_bits,<span class="keyword">...</span>
    frm.payload_len_bits];

frm.header_final = [frm.preamble,<span class="keyword">...</span><span class="comment">                                                        % construct final frame header with end flag high</span>
    frm.preamble_pad,<span class="keyword">...</span>
    frm.end_flag_high,<span class="keyword">...</span>
    frm.header_len_bits,<span class="keyword">...</span>
    frm.payload_len_bits];
</pre><h2>Message Acquisition &amp; Frame/ Padding Calculation<a name="4"></a></h2><pre class="codeinput"><span class="comment">%-------------------------------------------------------------------------%</span>
<span class="comment">% -Load image data</span>
<span class="comment">% -Calculate length of data to be transmitted in bits</span>
<span class="comment">% -Calculate # of frames required and pad lengths; three possibilities:</span>
<span class="comment">%       &gt; Only one frame is needed to transmit data:</span>
<span class="comment">%                 Either - [___Header___|__________Data_________|_Padding_]</span>
<span class="comment">%                 Or -     [___Header___|______Data_____|_____Padding_____]</span>
<span class="comment">%</span>
<span class="comment">%       &gt; More than one frame is needed; last frame's data field is full:</span>
<span class="comment">%             All Frames - [___Header___|__________Data_________|_Padding_]</span>
<span class="comment">%</span>
<span class="comment">%       &gt; More than one frame is needed; last frame's data field is not</span>
<span class="comment">%         full and requires a larger amount of padding:</span>
<span class="comment">%          Normal Frames - [___Header___|__________Data_________|_Padding_]</span>
<span class="comment">%             Last Frame - [___Header___|______Data_____|_____Padding_____]</span>
<span class="comment">%</span>
<span class="comment">%-------------------------------------------------------------------------%</span>

frm.input = load(frm.filename);                                                             <span class="comment">% acquire the data to be sent</span>
frm.image_size = size(frm.input.image);                                                     <span class="comment">% find the dimensions of the image</span>
frm.total_img_pixels = frm.image_size(:,1)*frm.image_size(:,2);                             <span class="comment">% find the number of pixels in the image</span>
frm.pixels_bit_len = frm.total_img_pixels*frm.binary_len;                                   <span class="comment">% convert this length to a binary representation length</span>

frm.padding_len = frm.payload_len - frm.data_len;                                           <span class="comment">% calculate the # of padding bits required in a 'normal' frame</span>
frm.normal_frame_pad = randi([0 1], 1, frm.padding_len);                                    <span class="comment">% create variable and store normal frame padding</span>
frm.pad_bits_norm = de2bi(int8(frm.padding_len),frm.pad_bit_len,<span class="string">'left-msb'</span>);                <span class="comment">% convert padding length to binary representation</span>
frm.header_norm = [frm.header_norm, frm.pad_bits_norm];                                     <span class="comment">% append binary representation to normal frame header</span>

<span class="keyword">if</span> frm.pixels_bit_len &gt; frm.data_len                                                        <span class="comment">% execute if the data to be transmitted is longer than the data length of one frame</span>
    frm.final_data_bits = rem(frm.pixels_bit_len,frm.data_len);                             <span class="comment">% calculate the amount of data that will be sent in the last frame</span>
    <span class="keyword">if</span> frm.final_data_bits &gt; 0                                                              <span class="comment">% execute if the last frame's data does not exactly equal the data_len</span>
        frm.no_of_frames = floor(frm.pixels_bit_len/frm.data_len) + 1;                      <span class="comment">% calculate the # of frames required, including the additional last frame</span>
        frm.final_frame_pad = randi([0 1], 1, frm.payload_len - frm.final_data_bits);       <span class="comment">% calculate the padding required for the last frame</span>
    <span class="keyword">else</span>
        frm.no_of_frames = floor(frm.pixels_bit_len/frm.data_len);                          <span class="comment">% calculate the # of frames when the image data is exactly divisible by the data_len</span>
        frm.final_frame_pad = frm.normal_frame_pad;                                         <span class="comment">% final frame padding is the same as a normal frame padding in this case</span>
    <span class="keyword">end</span>
    frm.pad_len_final = length(frm.final_frame_pad);                                        <span class="comment">% find decimal length of final frame padding</span>
    frm.pad_bits_final = de2bi(frm.pad_len_final,frm.pad_bit_len,<span class="string">'left-msb'</span>);               <span class="comment">% convert value to binary form</span>
    frm.header_final = [frm.header_final, frm.pad_bits_final];                              <span class="comment">% append binary representation to final frame header</span>
<span class="keyword">else</span>                                                                                        <span class="comment">% execute if data to be transmitted can be sent using one frame</span>
    frm.no_of_frames = 1;                                                                   <span class="comment">% set frame # to 1</span>
    <span class="keyword">if</span> frm.pixels_bit_len == frm.data_len                                                   <span class="comment">% execute if the data to be transmitted exactly fills the data_len space in the frame</span>
        frm.one_frame_pad = frm.normal_frame_pad;                                           <span class="comment">% set the padding for this one frame equal to normal frame padding</span>
    <span class="keyword">else</span>                                                                                    <span class="comment">% execute if the data to be transmitted is less than the data_len space in the frame</span>
        frm.one_frame_pad = randi([0 1], 1, frm.payload_len-frm.pixels_bit_len);            <span class="comment">% create the larger padding required for this frame</span>
    <span class="keyword">end</span>
    frm.pad_len_one = length(frm.one_frame_pad);                                            <span class="comment">% find decimal length of the one frame padding</span>
    frm.pad_bits_one = de2bi(frm.pad_len_one,frm.pad_bit_len,<span class="string">'left-msb'</span>);                   <span class="comment">% convert value to binary form</span>
    frm.header_one = [frm.header_final, frm.pad_bits_one];                                  <span class="comment">% append binary representation to final frame header; as one frame in this case is the final frame</span>
<span class="keyword">end</span>
</pre><h2>Data Segmentation, Payload Creation &amp; Frame Construction<a name="5"></a></h2><pre class="codeinput"><span class="comment">% convert decimal pixel values to a matrix of binary bits</span>
frm.binary_image = reshape(frm.input.image,1,frm.total_img_pixels)';                        <span class="comment">% reshape loaded data to a single column of data</span>
frm.binary_image = de2bi(frm.binary_image,frm.binary_len,<span class="string">'left-msb'</span>);                       <span class="comment">% convert decimal values to binary representations</span>

<span class="comment">% reshape ascii matrix into a single vector</span>
frm.temp_storage = reshape(frm.binary_image',frm.pixels_bit_len,1)';                        <span class="comment">% reshape binary row representations to a single row of data</span>

frm.hasField = isfield(frm , <span class="string">'master_frame'</span>);                                               <span class="comment">% test to see if 'master_frame' already exists in the 'frm' structure</span>
<span class="keyword">if</span> frm.hasField
    frm = rmfield(frm , <span class="string">'master_frame'</span>);                                                    <span class="comment">% if it exists, remove it</span>
<span class="keyword">end</span>

<span class="keyword">for</span> i = 1:1:frm.no_of_frames                                                                <span class="comment">% loop for # of frames calculated earlier</span>
    <span class="keyword">if</span> frm.no_of_frames == 1;                                                               <span class="comment">% if only one frame - construct frame with header_one and one_frame_pad</span>
        frm.master_frame = [frm.header_one(1:frm.preamble_len+frm.preamble_pad_len),<span class="keyword">...</span><span class="comment">     % preamble sequence</span>
                             de2bi(i,frm.seq_num_bit_len,<span class="string">'left-msb'</span>),<span class="keyword">...</span><span class="comment">                    % convert frame number to binary representation for sequence number</span>
                             frm.header_one(frm.preamble_len+frm.preamble_pad_len+1:end),<span class="keyword">...</span><span class="comment">                     % remaining header fields</span>
                             frm.temp_storage(1:end),<span class="keyword">...</span><span class="comment">                                    % all of the data to be transmitted in data field of frame</span>
                             frm.one_frame_pad];                                            <span class="comment">% one frame padding</span>
    <span class="keyword">else</span>
        <span class="keyword">if</span> i ~= frm.no_of_frames
            frm.temp_frame = [frm.header_norm(1:frm.preamble_len+frm.preamble_pad_len),<span class="keyword">...</span><span class="comment">  % preamble sequence</span>
                               de2bi(i,frm.seq_num_bit_len,<span class="string">'left-msb'</span>),<span class="keyword">...</span><span class="comment">                  % convert frame number to binary representation for sequence number</span>
                               frm.header_norm(frm.preamble_len+frm.preamble_pad_len+1:end),<span class="keyword">...</span><span class="comment">                  % remaining header fields</span>
                               frm.temp_storage(((i-1)*frm.data_len)+1:i*frm.data_len),<span class="keyword">...</span><span class="comment">  % fill data_len field with a part of the image data</span>
                               frm.normal_frame_pad];                                       <span class="comment">% normal frame padding</span>
        <span class="keyword">else</span>
            frm.temp_frame = [frm.header_final(1:frm.preamble_len+frm.preamble_pad_len),<span class="keyword">...</span><span class="comment"> % preamble sequence</span>
                               de2bi(i,frm.seq_num_bit_len,<span class="string">'left-msb'</span>),<span class="keyword">...</span><span class="comment">                  % convert frame number to binary representation for sequence number</span>
                               frm.header_final(frm.preamble_len+frm.preamble_pad_len+1:end),<span class="keyword">...</span><span class="comment">                 % remaining header fields</span>
                               frm.temp_storage(((i-1)*frm.data_len)+1:end),<span class="keyword">...</span><span class="comment">             % fill data_len field with remaining image data</span>
                               frm.final_frame_pad];                                        <span class="comment">% final frame padding</span>
        <span class="keyword">end</span>
        frm.master_frame(:,i) = frm.temp_frame;                                             <span class="comment">% store each generated frame in a master_frame variable</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
clear(<span class="string">'i'</span>);                                                                                 <span class="comment">% clear the frame # counter</span>

frm.master_frame_len = length(frm.temp_frame);                                              <span class="comment">% determine length of master frame</span>

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><h2>Software, Simulation Examples and Design Exercises Licence Agreement  %%<a name="6"></a></h2><pre class="codeinput"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%</span>
<span class="comment">%  This license agreement refers to the simulation examples, design</span>
<span class="comment">%  exercises and files, and associated software MATLAB and Simulink</span>
<span class="comment">%  resources that accompany the book:</span>
<span class="comment">%</span>
<span class="comment">%    Title: Software Defined Radio using MATLAB &amp; Simulink and the RTL-SDR</span>
<span class="comment">%    Published by Strathclyde Academic Media, 2015</span>
<span class="comment">%    Authored by Robert W. Stewart, Kenneth W. Barlee, Dale S.W. Atkinson,</span>
<span class="comment">%    and Louise H. Crockett</span>
<span class="comment">%</span>
<span class="comment">%  and made available as a download from www.desktopSDR.com or variously</span>
<span class="comment">%  acquired by other means such as via USB storage, cloud storage, disk or</span>
<span class="comment">%  any other electronic or optical or magnetic storage mechanism. These</span>
<span class="comment">%  files and associated software may be used subject to the terms of</span>
<span class="comment">%  agreement of the conditions below:</span>
<span class="comment">%</span>
<span class="comment">%    Copyright &copy; 2015 Robert W. Stewart, Kenneth W. Barlee,</span>
<span class="comment">%    Dale S.W. Atkinson, and Louise H. Crockett. All rights reserved.</span>
<span class="comment">%</span>
<span class="comment">%  Redistribution and use in source and binary forms, with or without</span>
<span class="comment">%  modification, are permitted provided that the following conditions are</span>
<span class="comment">%  met:</span>
<span class="comment">%</span>
<span class="comment">%   (1) Redistributions of source code must retain the above copyright</span>
<span class="comment">%       notice, this list of conditions and the following disclaimer.</span>
<span class="comment">%</span>
<span class="comment">%   (2) Redistributions in binary form must reproduce the above copyright</span>
<span class="comment">%       notice, this list of conditions and the following disclaimer in</span>
<span class="comment">%       the documentation and/or other materials provided with the</span>
<span class="comment">%       distribution.</span>
<span class="comment">%</span>
<span class="comment">%   (3) Neither the name of the copyright holder nor the names of its</span>
<span class="comment">%       contributors may be used to endorse or promote products derived</span>
<span class="comment">%       from this software without specific prior written permission.</span>
<span class="comment">%</span>
<span class="comment">%   (4) In all cases, the software is, and all modifications and</span>
<span class="comment">%       derivatives of the software shall be, licensed to you solely for</span>
<span class="comment">%       use in conjunction with The MathWorks, Inc. products and service</span>
<span class="comment">%       offerings.</span>
<span class="comment">%</span>
<span class="comment">%  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="comment">%  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="comment">%  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="comment">%  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="comment">%  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="comment">%  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="comment">%  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="comment">%  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="comment">%  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="comment">%  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="comment">%  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="comment">%</span>
</pre><h2>Audio Tracks used in Simulations Examples and Design Exercises<a name="7"></a></h2><pre>The music and vocal files used within the Examples files and software
within the book were variously written, arranged, performed, recorded
and produced by Garrey Rice, Adam Struth, Jamie Struth, Iain
Thistlethwaite and also Marshall Craigmyle who collectively, and
individually where appropriate, assert and retain all of their
copyright, performance and artistic rights. Permission to use and
reproduce this music is granted for all purposes associated with
MATLAB and Simulink software and the simulation examples and design
exercises files that accompany this book. Requests to use the music
for any other purpose should be directed to: info@desktopSDR.com. For
information on music track names, full credits, and links to the
musicians please refer to www.desktopSDR.com/more/audio.</pre><pre class="codeinput"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Image Framing Script - Used by the Transmitter for Frame Generation
% The code loads the image to be transmitted and implements a segmentation
% process to store columns of the image in individual frames. These frames
% are constructed from a header which contains the preamble sequence and
% information fields, and the payload with appended padding. The padding
% ensures that all frames are of equal length.
%
% The frame structure used is shown here:
%
% General Frame Structure: [___Header___|_____________Payload_____________]
%
% Normal Frame - with pad: [___Header___|__________Data_________|_Padding_]
%
% When the data in a frame is less than the data field length:
%
% Padding increases:       [___Header___|______Data_____|_____Padding_____]

%% Obtain Parameters Set in the Simulink Block Mask
frm.filename = get_param(gcbh,'filename');                                                  % obtain the filename of the image to be sent
frm.binary_len = str2num( get_param(gcbh,'binary_len') );                                   % obtain the ASCII length and convert char type to num 
frm.fs = str2num( get_param(gcbh,'fs') );                                                   % obtain the sampling rate and convert char type to num 

%% Declare Protocol Parameters

% frame length declaration
frm.frame_len = 1000;                                                                       % total length of a frame

% bit length declarations
frm.seq_num_bit_len = 8;                                                                    % # of bits in header - frame sequence number length
frm.end_flag_bit_len = 1;                                                                   % # of bits in header - end frame flag length
frm.header_bit_len = 8;                                                                     % # of bits in header - header length
frm.payload_bit_len = 10;                                                                   % # of bits in header - payload length
frm.pad_bit_len = 9;                                                                        % # of bits in header - padding length

%% Frame Header Structure
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%
% Frame Header- [preamble, sequence number, end flag, header length,
%                payload length, padding length]
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%

% set the preamble in unipolar form - used at the beginning of each frame
frm.preamble = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1];
frm.preamble_len = length(frm.preamble);                                                    % calculate decimal length of the preamble sequence
frm.preamble_pad_len = rem(frm.preamble_len,2);                                             % determine if preamble requires padding
frm.preamble_pad = zeros(1,frm.preamble_pad_len);                                           % create padding to make preamble an even length (if required)

% determine the length of the header from the individual field lengths
frm.header_len = frm.preamble_len...                                                        % calculate the full length of the header (bits)
    + frm.preamble_pad_len...
    + frm.seq_num_bit_len...
    + frm.end_flag_bit_len...
    + frm.header_bit_len...
    + frm.payload_bit_len...
    + frm.pad_bit_len;

frm.payload_len = frm.frame_len - frm.header_len;                                           % calculate the # of available payload storage bits in a frame
frm.data_len = 800;                                                                         % set at this value to transmit one pixel column per frame

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%
% convert decimal lengths of fields to binary and construct header
frm.end_flag_low = 0;                                                                       % declare data end flag low for all frames but last
frm.end_flag_high = 1;                                                                      % declare data end flag high for last frame
frm.header_len_bits = de2bi(frm.header_len,frm.header_bit_len,'left-msb');                  % convert decimal header length to binary representation
frm.payload_len_bits = de2bi(frm.payload_len,frm.payload_bit_len,'left-msb');               % convert decimal payload length to binary representation

frm.header_norm = [frm.preamble,...                                                         % construct normal frame header with end flag low
    frm.preamble_pad,...
    frm.end_flag_low,...
    frm.header_len_bits,...
    frm.payload_len_bits];

frm.header_final = [frm.preamble,...                                                        % construct final frame header with end flag high
    frm.preamble_pad,...
    frm.end_flag_high,...
    frm.header_len_bits,...
    frm.payload_len_bits];

%% Message Acquisition & Frame/ Padding Calculation
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%
% -Load image data
% -Calculate length of data to be transmitted in bits
% -Calculate # of frames required and pad lengths; three possibilities:
%       > Only one frame is needed to transmit data:
%                 Either - [___Header___|__________Data_________|_Padding_]
%                 Or -     [___Header___|______Data_____|_____Padding_____]
%
%       > More than one frame is needed; last frame's data field is full:
%             All Frames - [___Header___|__________Data_________|_Padding_]
%
%       > More than one frame is needed; last frame's data field is not
%         full and requires a larger amount of padding:
%          Normal Frames - [___Header___|__________Data_________|_Padding_]
%             Last Frame - [___Header___|______Data_____|_____Padding_____]
%
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%

frm.input = load(frm.filename);                                                             % acquire the data to be sent
frm.image_size = size(frm.input.image);                                                     % find the dimensions of the image
frm.total_img_pixels = frm.image_size(:,1)*frm.image_size(:,2);                             % find the number of pixels in the image
frm.pixels_bit_len = frm.total_img_pixels*frm.binary_len;                                   % convert this length to a binary representation length

frm.padding_len = frm.payload_len - frm.data_len;                                           % calculate the # of padding bits required in a 'normal' frame
frm.normal_frame_pad = randi([0 1], 1, frm.padding_len);                                    % create variable and store normal frame padding                                       
frm.pad_bits_norm = de2bi(int8(frm.padding_len),frm.pad_bit_len,'left-msb');                % convert padding length to binary representation
frm.header_norm = [frm.header_norm, frm.pad_bits_norm];                                     % append binary representation to normal frame header

if frm.pixels_bit_len > frm.data_len                                                        % execute if the data to be transmitted is longer than the data length of one frame
    frm.final_data_bits = rem(frm.pixels_bit_len,frm.data_len);                             % calculate the amount of data that will be sent in the last frame
    if frm.final_data_bits > 0                                                              % execute if the last frame's data does not exactly equal the data_len 
        frm.no_of_frames = floor(frm.pixels_bit_len/frm.data_len) + 1;                      % calculate the # of frames required, including the additional last frame             
        frm.final_frame_pad = randi([0 1], 1, frm.payload_len - frm.final_data_bits);       % calculate the padding required for the last frame
    else
        frm.no_of_frames = floor(frm.pixels_bit_len/frm.data_len);                          % calculate the # of frames when the image data is exactly divisible by the data_len
        frm.final_frame_pad = frm.normal_frame_pad;                                         % final frame padding is the same as a normal frame padding in this case
    end
    frm.pad_len_final = length(frm.final_frame_pad);                                        % find decimal length of final frame padding
    frm.pad_bits_final = de2bi(frm.pad_len_final,frm.pad_bit_len,'left-msb');               % convert value to binary form
    frm.header_final = [frm.header_final, frm.pad_bits_final];                              % append binary representation to final frame header
else                                                                                        % execute if data to be transmitted can be sent using one frame
    frm.no_of_frames = 1;                                                                   % set frame # to 1
    if frm.pixels_bit_len == frm.data_len                                                   % execute if the data to be transmitted exactly fills the data_len space in the frame
        frm.one_frame_pad = frm.normal_frame_pad;                                           % set the padding for this one frame equal to normal frame padding
    else                                                                                    % execute if the data to be transmitted is less than the data_len space in the frame                   
        frm.one_frame_pad = randi([0 1], 1, frm.payload_len-frm.pixels_bit_len);            % create the larger padding required for this frame
    end
    frm.pad_len_one = length(frm.one_frame_pad);                                            % find decimal length of the one frame padding
    frm.pad_bits_one = de2bi(frm.pad_len_one,frm.pad_bit_len,'left-msb');                   % convert value to binary form
    frm.header_one = [frm.header_final, frm.pad_bits_one];                                  % append binary representation to final frame header; as one frame in this case is the final frame
end

%% Data Segmentation, Payload Creation & Frame Construction

% convert decimal pixel values to a matrix of binary bits
frm.binary_image = reshape(frm.input.image,1,frm.total_img_pixels)';                        % reshape loaded data to a single column of data 
frm.binary_image = de2bi(frm.binary_image,frm.binary_len,'left-msb');                       % convert decimal values to binary representations

% reshape ascii matrix into a single vector
frm.temp_storage = reshape(frm.binary_image',frm.pixels_bit_len,1)';                        % reshape binary row representations to a single row of data

frm.hasField = isfield(frm , 'master_frame');                                               % test to see if 'master_frame' already exists in the 'frm' structure
if frm.hasField
    frm = rmfield(frm , 'master_frame');                                                    % if it exists, remove it
end

for i = 1:1:frm.no_of_frames                                                                % loop for # of frames calculated earlier
    if frm.no_of_frames == 1;                                                               % if only one frame - construct frame with header_one and one_frame_pad
        frm.master_frame = [frm.header_one(1:frm.preamble_len+frm.preamble_pad_len),...     % preamble sequence
                             de2bi(i,frm.seq_num_bit_len,'left-msb'),...                    % convert frame number to binary representation for sequence number
                             frm.header_one(frm.preamble_len+frm.preamble_pad_len+1:end),...                     % remaining header fields
                             frm.temp_storage(1:end),...                                    % all of the data to be transmitted in data field of frame
                             frm.one_frame_pad];                                            % one frame padding
    else
        if i ~= frm.no_of_frames
            frm.temp_frame = [frm.header_norm(1:frm.preamble_len+frm.preamble_pad_len),...  % preamble sequence
                               de2bi(i,frm.seq_num_bit_len,'left-msb'),...                  % convert frame number to binary representation for sequence number
                               frm.header_norm(frm.preamble_len+frm.preamble_pad_len+1:end),...                  % remaining header fields
                               frm.temp_storage(((i-1)*frm.data_len)+1:i*frm.data_len),...  % fill data_len field with a part of the image data
                               frm.normal_frame_pad];                                       % normal frame padding
        else
            frm.temp_frame = [frm.header_final(1:frm.preamble_len+frm.preamble_pad_len),... % preamble sequence
                               de2bi(i,frm.seq_num_bit_len,'left-msb'),...                  % convert frame number to binary representation for sequence number
                               frm.header_final(frm.preamble_len+frm.preamble_pad_len+1:end),...                 % remaining header fields
                               frm.temp_storage(((i-1)*frm.data_len)+1:end),...             % fill data_len field with remaining image data
                               frm.final_frame_pad];                                        % final frame padding
        end
        frm.master_frame(:,i) = frm.temp_frame;                                             % store each generated frame in a master_frame variable
    end
end
clear('i');                                                                                 % clear the frame # counter

frm.master_frame_len = length(frm.temp_frame);                                              % determine length of master frame

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Software, Simulation Examples and Design Exercises Licence Agreement  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                         
%  This license agreement refers to the simulation examples, design
%  exercises and files, and associated software MATLAB and Simulink
%  resources that accompany the book:
% 
%    Title: Software Defined Radio using MATLAB & Simulink and the RTL-SDR 
%    Published by Strathclyde Academic Media, 2015
%    Authored by Robert W. Stewart, Kenneth W. Barlee, Dale S.W. Atkinson, 
%    and Louise H. Crockett
%
%  and made available as a download from www.desktopSDR.com or variously 
%  acquired by other means such as via USB storage, cloud storage, disk or 
%  any other electronic or optical or magnetic storage mechanism. These 
%  files and associated software may be used subject to the terms of 
%  agreement of the conditions below:
%
%    Copyright © 2015 Robert W. Stewart, Kenneth W. Barlee, 
%    Dale S.W. Atkinson, and Louise H. Crockett. All rights reserved.
%
%  Redistribution and use in source and binary forms, with or without 
%  modification, are permitted provided that the following conditions are
%  met:
%
%   (1) Redistributions of source code must retain the above copyright 
%       notice, this list of conditions and the following disclaimer.
%
%   (2) Redistributions in binary form must reproduce the above copyright
%       notice, this list of conditions and the following disclaimer in 
%       the documentation and/or other materials provided with the 
%       distribution.
%
%   (3) Neither the name of the copyright holder nor the names of its 
%       contributors may be used to endorse or promote products derived 
%       from this software without specific prior written permission.
%
%   (4) In all cases, the software is, and all modifications and 
%       derivatives of the software shall be, licensed to you solely for
%       use in conjunction with The MathWorks, Inc. products and service
%       offerings.
%
%  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
%  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
%  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
%  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
%  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
%  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
%  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
%  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
%  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
%  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
%  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%%  Audio Tracks used in Simulations Examples and Design Exercises
% 
%  The music and vocal files used within the Examples files and software 
%  within the book were variously written, arranged, performed, recorded 
%  and produced by Garrey Rice, Adam Struth, Jamie Struth, Iain 
%  Thistlethwaite and also Marshall Craigmyle who collectively, and 
%  individually where appropriate, assert and retain all of their 
%  copyright, performance and artistic rights. Permission to use and 
%  reproduce this music is granted for all purposes associated with 
%  MATLAB and Simulink software and the simulation examples and design 
%  exercises files that accompany this book. Requests to use the music 
%  for any other purpose should be directed to: info@desktopSDR.com. For
%  information on music track names, full credits, and links to the 
%  musicians please refer to www.desktopSDR.com/more/audio.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
##### SOURCE END #####
--></body></html>